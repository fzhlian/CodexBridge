import {
  CODEX_METHODS,
  CodexAppServerClient,
  type CodexClientOptions
} from "@codexbridge/codex-client";
import { buildPatchContext, type PatchContext, type RuntimeContextSnapshot } from "./context.js";

const client = new CodexAppServerClient(getClientOptions());

export async function generatePatchFromCodex(
  prompt: string,
  workspaceRoot: string,
  runtimeContext?: RuntimeContextSnapshot
): Promise<{ diff: string; summary: string }> {
  const context = await buildPatchContext(workspaceRoot, prompt, runtimeContext);
  try {
    const response = await client.request(CODEX_METHODS.PATCH, {
      prompt,
      context
    });
    return parsePatchResponse(response);
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    if (!shouldFallbackToExec(message)) {
      throw error;
    }

    const response = await client.request(CODEX_METHODS.COMMAND_EXEC, {
      command: [
        process.env.CODEX_COMMAND ?? "codex",
        "exec",
        "--skip-git-repo-check",
        "--dangerously-bypass-approvals-and-sandbox",
        "--cd",
        workspaceRoot,
        buildExecPrompt(prompt, context)
      ],
      timeoutMs: Number(process.env.CODEX_EXEC_TIMEOUT_MS ?? "180000")
    });
    return parseCommandExecPatchResponse(response);
  }
}

function parsePatchResponse(response: unknown): { diff: string; summary: string } {
  if (typeof response === "string") {
    return {
      diff: response,
      summary: "patch generated by codex"
    };
  }

  if (response && typeof response === "object") {
    const value = response as Record<string, unknown>;
    const diffCandidate = pickString(value, [
      "diff",
      "patch",
      "content",
      "output_text",
      "text"
    ]);
    const summary = pickString(value, ["summary", "message"]) ?? "patch generated by codex";
    if (diffCandidate) {
      return {
        diff: diffCandidate,
        summary
      };
    }
  }

  throw new Error("invalid codex patch response: missing diff");
}

function pickString(
  source: Record<string, unknown>,
  keys: string[]
): string | undefined {
  for (const key of keys) {
    const value = source[key];
    if (typeof value === "string" && value.trim()) {
      return value;
    }
  }
  return undefined;
}

function getClientOptions(): CodexClientOptions {
  return {
    command: process.env.CODEX_COMMAND ?? "codex",
    args: process.env.CODEX_ARGS
      ? process.env.CODEX_ARGS.split(",").map((value) => value.trim())
      : ["app-server"],
    requestTimeoutMs: Number(process.env.CODEX_REQUEST_TIMEOUT_MS ?? "240000"),
    restartOnExit: true
  };
}

function shouldFallbackToExec(message: string): boolean {
  const normalized = message.toLowerCase();
  return normalized.includes("unknown variant `patch`")
    || normalized.includes("not initialized")
    || normalized.includes("method not found");
}

function buildExecPrompt(prompt: string, context: PatchContext): string {
  const maxSummaryChars = Number(process.env.CODEX_EXEC_CONTEXT_SUMMARY_MAX_CHARS ?? "4000");
  const maxFileChars = Number(process.env.CODEX_EXEC_CONTEXT_FILE_MAX_CHARS ?? "3000");
  const maxFiles = Number(process.env.CODEX_EXEC_CONTEXT_MAX_FILES ?? "2");
  const maxPromptChars = Number(process.env.CODEX_EXEC_PROMPT_MAX_CHARS ?? "9000");

  const safeSummary = truncate(context.summary, maxSummaryChars);
  const files = context.files.slice(0, Math.max(0, maxFiles));
  const filesSection = context.files.length > 0
    ? files
      .map((file) => `FILE: ${file.path}\n${truncate(file.content, maxFileChars)}`)
      .join("\n\n")
    : "No file snippets available.";

  const raw = [
    "You are generating a git patch for CodexBridge.",
    "Return only a unified diff patch that can be applied with git apply.",
    "Do not include explanations or markdown fences.",
    `Task: ${prompt}`,
    "",
    "Workspace summary:",
    safeSummary,
    "",
    "File snippets:",
    filesSection,
    "",
    "Runtime context:",
    JSON.stringify(context.runtime ?? {}, null, 2)
  ].join("\n");

  return truncate(raw, maxPromptChars);
}

function parseCommandExecPatchResponse(response: unknown): { diff: string; summary: string } {
  if (!response || typeof response !== "object") {
    throw new Error("invalid command/exec response");
  }
  const value = response as Record<string, unknown>;
  const exitCode = Number(value.exitCode ?? 1);
  const stdout = typeof value.stdout === "string" ? value.stdout : "";
  const stderr = typeof value.stderr === "string" ? value.stderr : "";
  if (exitCode !== 0) {
    throw new Error(`codex exec failed: ${stderr || `exitCode=${exitCode}`}`);
  }

  const diff = extractDiff(stdout);
  if (!diff) {
    throw new Error("codex exec returned no diff content");
  }
  return {
    diff,
    summary: "patch generated by codex exec fallback"
  };
}

function extractDiff(output: string): string | undefined {
  const trimmed = output.trim();
  if (!trimmed) {
    return undefined;
  }

  const fenced = trimmed.match(/```diff\s*([\s\S]*?)```/i);
  if (fenced && fenced[1]) {
    return fenced[1].trim();
  }

  const diffMarker = trimmed.search(/^diff --git /m);
  if (diffMarker >= 0) {
    return trimmed.slice(diffMarker).trim();
  }

  if (/^--- .+\n\+\+\+ .+/m.test(trimmed) || /^@@ /m.test(trimmed)) {
    return trimmed;
  }

  return undefined;
}

function truncate(input: string, maxChars: number): string {
  const safeMax = Number.isFinite(maxChars) && maxChars > 0 ? Math.floor(maxChars) : 1000;
  if (input.length <= safeMax) {
    return input;
  }
  return `${input.slice(0, safeMax)}\n...[truncated]`;
}
