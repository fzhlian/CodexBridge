import {
  readdirSync,
  existsSync,
  statSync,
  type Dirent,
} from "node:fs";
import os from "node:os";
import path from "node:path";
import { spawn } from "node:child_process";
import {
  CODEX_METHODS,
  CodexAppServerClient,
  type CodexClientOptions
} from "@codexbridge/codex-client";
import { buildPatchContext, type PatchContext, type RuntimeContextSnapshot } from "./context.js";

let client: CodexAppServerClient | undefined;
let patchRpcDisabledUntilMs = 0;

type PatchRpcPolicy = "auto" | "always" | "never";

export async function generatePatchFromCodex(
  prompt: string,
  workspaceRoot: string,
  runtimeContext?: RuntimeContextSnapshot,
  signal?: AbortSignal
): Promise<{ diff: string; summary: string }> {
  const context = await buildPatchContext(workspaceRoot, prompt, runtimeContext);
  const patchRequestTimeoutMs = resolvePatchRequestTimeoutMs();
  const execTimeoutMs = Number(
    process.env.CODEX_EXEC_TIMEOUT_MS
    ?? "600000"
  );
  const execRequestTimeoutMs = Number(
    process.env.CODEX_EXEC_REQUEST_TIMEOUT_MS
    ?? process.env.CODEX_REQUEST_TIMEOUT_MS
    ?? String(execTimeoutMs + 60000)
  );
  if (shouldAttemptPatchRpc()) {
    try {
      const response = await getClient().request(CODEX_METHODS.PATCH, {
        prompt,
        context
      }, { signal, timeoutMs: patchRequestTimeoutMs });
      markPatchRpcHealthy();
      return parsePatchResponse(response);
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      if (!shouldFallbackToExec(message)) {
        throw error;
      }
      markPatchRpcUnavailable();
    }
  }

  const command = resolveCodexCommand();
  const args = [
    "exec",
    "--skip-git-repo-check",
    "--dangerously-bypass-approvals-and-sandbox",
    "--cd",
    workspaceRoot,
    buildExecPrompt(prompt, context)
  ];

  if (shouldPreferDirectExecFallback()) {
    try {
      const direct = await runDirectCommand(command, args, workspaceRoot, execTimeoutMs, signal);
      return parseCommandExecPatchResponse(direct, "patch generated by codex exec direct fallback");
    } catch {
      // fall through to app-server command/exec fallback
    }
  }

  const response = await getClient().request(
    CODEX_METHODS.COMMAND_EXEC,
    {
      command: [command, ...args],
      timeoutMs: execTimeoutMs
    },
    { signal, timeoutMs: execRequestTimeoutMs }
  );
  return parseCommandExecPatchResponse(response, "patch generated by codex exec fallback");
}

function parsePatchResponse(response: unknown): { diff: string; summary: string } {
  if (typeof response === "string") {
    return {
      diff: response,
      summary: "patch generated by codex"
    };
  }

  if (response && typeof response === "object") {
    const value = response as Record<string, unknown>;
    const diffCandidate = pickString(value, [
      "diff",
      "patch",
      "content",
      "output_text",
      "text"
    ]);
    const summary = pickString(value, ["summary", "message"]) ?? "patch generated by codex";
    if (diffCandidate) {
      return {
        diff: diffCandidate,
        summary
      };
    }
  }

  throw new Error("invalid codex patch response: missing diff");
}

function pickString(
  source: Record<string, unknown>,
  keys: string[]
): string | undefined {
  for (const key of keys) {
    const value = source[key];
    if (typeof value === "string" && value.trim()) {
      return value;
    }
  }
  return undefined;
}

function getClientOptions(): CodexClientOptions {
  return {
    command: resolveCodexCommand(),
    args: process.env.CODEX_ARGS
      ? process.env.CODEX_ARGS.split(",").map((value) => value.trim())
      : ["app-server"],
    requestTimeoutMs: Number(process.env.CODEX_REQUEST_TIMEOUT_MS ?? "240000"),
    restartOnExit: true
  };
}

function getClient(): CodexAppServerClient {
  if (!client) {
    client = new CodexAppServerClient(getClientOptions());
  }
  return client;
}

function resolveCodexCommand(): string {
  const explicit = process.env.CODEX_COMMAND?.trim();
  const explicitLooksGeneric = explicit
    ? /^(codex|codex\.exe)$/i.test(explicit)
    : false;
  if (explicit && !(process.platform === "win32" && explicitLooksGeneric)) {
    return explicit;
  }

  if (process.platform === "win32") {
    const userHome = os.homedir();
    const extRoot = path.join(userHome, ".vscode", "extensions");
    try {
      const entries: Dirent[] = readdirSync(extRoot, { withFileTypes: true });
      const candidates = entries
        .filter((entry) => entry.isDirectory() && entry.name.startsWith("openai.chatgpt-"))
        .map((entry) =>
          path.join(extRoot, entry.name, "bin", "windows-x86_64", "codex.exe")
        )
        .filter((candidate) => {
          try {
            return existsSync(candidate) && statSync(candidate).isFile();
          } catch {
            return false;
          }
        });
      if (candidates.length > 0) {
        candidates.sort();
        return candidates[candidates.length - 1];
      }
    } catch {
      // fallback to plain command name
    }
  }

  return "codex";
}

function shouldFallbackToExec(message: string): boolean {
  const normalized = message.toLowerCase();
  return normalized.includes("unknown variant `patch`")
    || normalized.includes("not initialized")
    || normalized.includes("method not found")
    || normalized.includes("request timeout")
    || normalized.includes("process exited before response");
}

function resolvePatchRpcPolicy(): PatchRpcPolicy {
  const raw = process.env.CODEX_PATCH_RPC_POLICY?.trim().toLowerCase();
  if (raw === "always") {
    return "always";
  }
  if (raw === "never") {
    return "never";
  }
  return "auto";
}

function shouldAttemptPatchRpc(): boolean {
  const policy = resolvePatchRpcPolicy();
  if (policy === "never") {
    return false;
  }
  if (policy === "always") {
    return true;
  }
  return Date.now() >= patchRpcDisabledUntilMs;
}

function resolvePatchRequestTimeoutMs(): number {
  return parsePositiveInt(
    process.env.CODEX_PATCH_REQUEST_TIMEOUT_MS
    ?? process.env.CODEX_PATCH_PROBE_TIMEOUT_MS
    ?? "8000",
    8000
  );
}

function resolvePatchRpcDisableMs(): number {
  return parsePositiveInt(process.env.CODEX_PATCH_RPC_DISABLE_MS ?? "900000", 900000);
}

function markPatchRpcUnavailable(): void {
  if (resolvePatchRpcPolicy() !== "auto") {
    return;
  }
  patchRpcDisabledUntilMs = Date.now() + resolvePatchRpcDisableMs();
}

function markPatchRpcHealthy(): void {
  patchRpcDisabledUntilMs = 0;
}

function buildExecPrompt(prompt: string, context: PatchContext): string {
  const maxSummaryChars = Number(process.env.CODEX_EXEC_CONTEXT_SUMMARY_MAX_CHARS ?? "4000");
  const maxFileChars = Number(process.env.CODEX_EXEC_CONTEXT_FILE_MAX_CHARS ?? "3000");
  const maxFiles = Number(process.env.CODEX_EXEC_CONTEXT_MAX_FILES ?? "2");
  const maxPromptChars = Number(process.env.CODEX_EXEC_PROMPT_MAX_CHARS ?? "9000");

  const safeSummary = truncate(context.summary, maxSummaryChars);
  const files = context.files.slice(0, Math.max(0, maxFiles));
  const filesSection = context.files.length > 0
    ? files
      .map((file) => `FILE: ${file.path}\n${truncate(file.content, maxFileChars)}`)
      .join("\n\n")
    : "No file snippets available.";

  const raw = [
    "You are generating a git patch for CodexBridge.",
    "Return only a unified diff patch that can be applied with git apply.",
    "Do not include explanations or markdown fences.",
    `Task: ${prompt}`,
    "",
    "Workspace summary:",
    safeSummary,
    "",
    "File snippets:",
    filesSection,
    "",
    "Runtime context:",
    JSON.stringify(context.runtime ?? {}, null, 2)
  ].join("\n");

  return truncate(raw, maxPromptChars);
}

function parseCommandExecPatchResponse(
  response: unknown,
  summary: string
): { diff: string; summary: string } {
  if (!response || typeof response !== "object") {
    throw new Error("invalid command/exec response");
  }
  const value = response as Record<string, unknown>;
  const exitCode = Number(value.exitCode ?? 1);
  const stdout = typeof value.stdout === "string" ? repairPossiblyMojibake(value.stdout) : "";
  const stderr = typeof value.stderr === "string" ? repairPossiblyMojibake(value.stderr) : "";
  if (exitCode !== 0) {
    throw new Error(`codex exec failed: ${stderr || `exitCode=${exitCode}`}`);
  }

  const diff = extractDiff(stdout);
  if (!diff) {
    throw new Error("codex exec returned no diff content");
  }
  return {
    diff,
    summary
  };
}

function extractDiff(output: string): string | undefined {
  const trimmed = output.trim();
  if (!trimmed) {
    return undefined;
  }

  const fenced = trimmed.match(/```diff\s*([\s\S]*?)```/i);
  if (fenced && fenced[1]) {
    return fenced[1].trim();
  }

  const diffMarker = trimmed.search(/^diff --git /m);
  if (diffMarker >= 0) {
    return trimmed.slice(diffMarker).trim();
  }

  if (/^--- .+\n\+\+\+ .+/m.test(trimmed) || /^@@ /m.test(trimmed)) {
    return trimmed;
  }

  return undefined;
}

function truncate(input: string, maxChars: number): string {
  const safeMax = Number.isFinite(maxChars) && maxChars > 0 ? Math.floor(maxChars) : 1000;
  if (input.length <= safeMax) {
    return input;
  }
  return `${input.slice(0, safeMax)}\n...[truncated]`;
}

function shouldPreferDirectExecFallback(): boolean {
  const raw = process.env.CODEX_DISABLE_DIRECT_EXEC_FALLBACK?.trim().toLowerCase();
  if (!raw) {
    return true;
  }
  return !["1", "true", "yes", "on"].includes(raw);
}

async function runDirectCommand(
  command: string,
  args: string[],
  workspaceRoot: string,
  timeoutMs: number,
  signal?: AbortSignal
): Promise<{ exitCode: number; stdout: string; stderr: string }> {
  if (signal?.aborted) {
    throw new Error("codex exec aborted");
  }

  return await new Promise((resolve, reject) => {
    const child = spawn(command, args, {
      cwd: workspaceRoot,
      stdio: "pipe",
      windowsHide: true
    });

    const stdoutChunks: Buffer[] = [];
    const stderrChunks: Buffer[] = [];
    let timedOut = false;
    let aborted = false;
    let settled = false;

    const settle = (result: { exitCode: number; stdout: string; stderr: string }): void => {
      if (settled) {
        return;
      }
      settled = true;
      cleanup();
      resolve(result);
    };

    const fail = (error: Error): void => {
      if (settled) {
        return;
      }
      settled = true;
      cleanup();
      reject(error);
    };

    const onAbort = (): void => {
      aborted = true;
      child.kill();
    };

    const timer = setTimeout(() => {
      timedOut = true;
      child.kill();
    }, timeoutMs);

    const cleanup = (): void => {
      clearTimeout(timer);
      signal?.removeEventListener("abort", onAbort);
    };

    signal?.addEventListener("abort", onAbort, { once: true });

    child.stdout.on("data", (chunk: Buffer) => {
      stdoutChunks.push(chunk);
    });
    child.stderr.on("data", (chunk: Buffer) => {
      stderrChunks.push(chunk);
    });

    child.on("error", (error) => {
      fail(error instanceof Error ? error : new Error(String(error)));
    });

    child.on("close", (code) => {
      const stdout = decodeExecOutputBuffer(Buffer.concat(stdoutChunks));
      const stderr = decodeExecOutputBuffer(Buffer.concat(stderrChunks));
      if (aborted) {
        fail(new Error("codex exec aborted"));
        return;
      }
      if (timedOut) {
        fail(new Error(`codex exec timed out after ${timeoutMs}ms`));
        return;
      }
      settle({
        exitCode: Number.isFinite(code ?? NaN) ? Number(code) : 1,
        stdout,
        stderr
      });
    });
  });
}

type ExecOutputEncodingMode = "auto" | "utf8" | "gbk";

const CJK_CHAR_REGEX = /[\u3400-\u9FFF]/g;
const REPLACEMENT_CHAR_REGEX = /\uFFFD/g;
const MOJIBAKE_HINT_REGEX = /[Ͱ-ϿЀ-ӿ]/g;

export function decodeExecOutputBuffer(
  value: Buffer,
  options: { platform?: NodeJS.Platform; mode?: ExecOutputEncodingMode } = {}
): string {
  if (value.length === 0) {
    return "";
  }

  const utf8 = value.toString("utf8");
  const mode = options.mode ?? resolveExecOutputEncodingMode();
  if (mode === "utf8") {
    return utf8;
  }

  const gbk = decodeBufferWithGbk(value);
  if (!gbk) {
    return utf8;
  }
  if (mode === "gbk") {
    return gbk;
  }

  const platform = options.platform ?? process.platform;
  if (platform !== "win32") {
    return utf8;
  }
  return shouldPreferGbkText(utf8, gbk) ? gbk : utf8;
}

function resolveExecOutputEncodingMode(): ExecOutputEncodingMode {
  const raw = process.env.CODEX_EXEC_OUTPUT_ENCODING?.trim().toLowerCase();
  if (raw === "utf8" || raw === "utf-8") {
    return "utf8";
  }
  if (raw === "gbk" || raw === "cp936") {
    return "gbk";
  }
  return "auto";
}

function decodeBufferWithGbk(value: Buffer): string | undefined {
  try {
    return new TextDecoder("gbk").decode(value);
  } catch {
    return undefined;
  }
}

function shouldPreferGbkText(utf8: string, gbk: string): boolean {
  const utf8Replacement = countByRegex(utf8, REPLACEMENT_CHAR_REGEX);
  const gbkReplacement = countByRegex(gbk, REPLACEMENT_CHAR_REGEX);
  if (utf8Replacement > 0 && gbkReplacement === 0) {
    return true;
  }

  const utf8Hint = countByRegex(utf8, MOJIBAKE_HINT_REGEX);
  const utf8Cjk = countByRegex(utf8, CJK_CHAR_REGEX);
  const gbkCjk = countByRegex(gbk, CJK_CHAR_REGEX);
  if (utf8Hint >= 2 && gbkCjk > utf8Cjk) {
    return true;
  }

  return false;
}

function countByRegex(input: string, regex: RegExp): number {
  const matches = input.match(regex);
  return matches ? matches.length : 0;
}

function repairPossiblyMojibake(input: string): string {
  if (!input || process.platform !== "win32") {
    return input;
  }
  return decodeExecOutputBuffer(Buffer.from(input, "utf8"), {
    platform: "win32",
    mode: "auto"
  });
}

function parsePositiveInt(raw: string, fallback: number): number {
  const parsed = Number(raw);
  if (Number.isFinite(parsed) && parsed > 0) {
    return Math.floor(parsed);
  }
  return fallback;
}
