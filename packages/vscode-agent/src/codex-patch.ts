import {
  CODEX_METHODS,
  CodexAppServerClient,
  type CodexClientOptions
} from "@codexbridge/codex-client";
import { buildPatchContext, type RuntimeContextSnapshot } from "./context.js";

const client = new CodexAppServerClient(getClientOptions());

export async function generatePatchFromCodex(
  prompt: string,
  workspaceRoot: string,
  runtimeContext?: RuntimeContextSnapshot
): Promise<{ diff: string; summary: string }> {
  const context = await buildPatchContext(workspaceRoot, prompt, runtimeContext);
  const response = await client.request(CODEX_METHODS.PATCH, {
    prompt,
    context
  });
  return parsePatchResponse(response);
}

function parsePatchResponse(response: unknown): { diff: string; summary: string } {
  if (typeof response === "string") {
    return {
      diff: response,
      summary: "patch generated by codex"
    };
  }

  if (response && typeof response === "object") {
    const value = response as Record<string, unknown>;
    const diffCandidate = pickString(value, [
      "diff",
      "patch",
      "content",
      "output_text",
      "text"
    ]);
    const summary = pickString(value, ["summary", "message"]) ?? "patch generated by codex";
    if (diffCandidate) {
      return {
        diff: diffCandidate,
        summary
      };
    }
  }

  throw new Error("invalid codex patch response: missing diff");
}

function pickString(
  source: Record<string, unknown>,
  keys: string[]
): string | undefined {
  for (const key of keys) {
    const value = source[key];
    if (typeof value === "string" && value.trim()) {
      return value;
    }
  }
  return undefined;
}

function getClientOptions(): CodexClientOptions {
  return {
    command: process.env.CODEX_COMMAND ?? "codex",
    args: process.env.CODEX_ARGS
      ? process.env.CODEX_ARGS.split(",").map((value) => value.trim())
      : ["app-server"],
    requestTimeoutMs: Number(process.env.CODEX_REQUEST_TIMEOUT_MS ?? "60000"),
    restartOnExit: true
  };
}
