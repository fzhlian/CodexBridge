import {
  readdirSync,
  existsSync,
  statSync,
  type Dirent,
} from "node:fs";
import os from "node:os";
import path from "node:path";
import {
  CODEX_METHODS,
  CodexAppServerClient,
  type CodexClientOptions
} from "@codexbridge/codex-client";
import { buildPatchContext, type PatchContext, type RuntimeContextSnapshot } from "./context.js";

let client: CodexAppServerClient | undefined;

export async function generatePatchFromCodex(
  prompt: string,
  workspaceRoot: string,
  runtimeContext?: RuntimeContextSnapshot,
  signal?: AbortSignal
): Promise<{ diff: string; summary: string }> {
  const context = await buildPatchContext(workspaceRoot, prompt, runtimeContext);
  const patchRequestTimeoutMs = Number(
    process.env.CODEX_PATCH_REQUEST_TIMEOUT_MS
    ?? process.env.CODEX_REQUEST_TIMEOUT_MS
    ?? "30000"
  );
  const execTimeoutMs = Number(
    process.env.CODEX_EXEC_TIMEOUT_MS
    ?? "600000"
  );
  const execRequestTimeoutMs = Number(
    process.env.CODEX_EXEC_REQUEST_TIMEOUT_MS
    ?? process.env.CODEX_REQUEST_TIMEOUT_MS
    ?? String(execTimeoutMs + 60000)
  );
  try {
    const response = await getClient().request(CODEX_METHODS.PATCH, {
      prompt,
      context
    }, { signal, timeoutMs: patchRequestTimeoutMs });
    return parsePatchResponse(response);
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    if (!shouldFallbackToExec(message)) {
      throw error;
    }

    const response = await getClient().request(CODEX_METHODS.COMMAND_EXEC, {
      command: [
        resolveCodexCommand(),
        "exec",
        "--skip-git-repo-check",
        "--dangerously-bypass-approvals-and-sandbox",
        "--cd",
        workspaceRoot,
        buildExecPrompt(prompt, context)
      ],
      timeoutMs: execTimeoutMs
    }, { signal, timeoutMs: execRequestTimeoutMs });
    return parseCommandExecPatchResponse(response);
  }
}

function parsePatchResponse(response: unknown): { diff: string; summary: string } {
  if (typeof response === "string") {
    return {
      diff: response,
      summary: "patch generated by codex"
    };
  }

  if (response && typeof response === "object") {
    const value = response as Record<string, unknown>;
    const diffCandidate = pickString(value, [
      "diff",
      "patch",
      "content",
      "output_text",
      "text"
    ]);
    const summary = pickString(value, ["summary", "message"]) ?? "patch generated by codex";
    if (diffCandidate) {
      return {
        diff: diffCandidate,
        summary
      };
    }
  }

  throw new Error("invalid codex patch response: missing diff");
}

function pickString(
  source: Record<string, unknown>,
  keys: string[]
): string | undefined {
  for (const key of keys) {
    const value = source[key];
    if (typeof value === "string" && value.trim()) {
      return value;
    }
  }
  return undefined;
}

function getClientOptions(): CodexClientOptions {
  return {
    command: resolveCodexCommand(),
    args: process.env.CODEX_ARGS
      ? process.env.CODEX_ARGS.split(",").map((value) => value.trim())
      : ["app-server"],
    requestTimeoutMs: Number(process.env.CODEX_REQUEST_TIMEOUT_MS ?? "240000"),
    restartOnExit: true
  };
}

function getClient(): CodexAppServerClient {
  if (!client) {
    client = new CodexAppServerClient(getClientOptions());
  }
  return client;
}

function resolveCodexCommand(): string {
  const explicit = process.env.CODEX_COMMAND?.trim();
  const explicitLooksGeneric = explicit
    ? /^(codex|codex\.exe)$/i.test(explicit)
    : false;
  if (explicit && !(process.platform === "win32" && explicitLooksGeneric)) {
    return explicit;
  }

  if (process.platform === "win32") {
    const userHome = os.homedir();
    const extRoot = path.join(userHome, ".vscode", "extensions");
    try {
      const entries: Dirent[] = readdirSync(extRoot, { withFileTypes: true });
      const candidates = entries
        .filter((entry) => entry.isDirectory() && entry.name.startsWith("openai.chatgpt-"))
        .map((entry) =>
          path.join(extRoot, entry.name, "bin", "windows-x86_64", "codex.exe")
        )
        .filter((candidate) => {
          try {
            return existsSync(candidate) && statSync(candidate).isFile();
          } catch {
            return false;
          }
        });
      if (candidates.length > 0) {
        candidates.sort();
        return candidates[candidates.length - 1];
      }
    } catch {
      // fallback to plain command name
    }
  }

  return "codex";
}

function shouldFallbackToExec(message: string): boolean {
  const normalized = message.toLowerCase();
  return normalized.includes("unknown variant `patch`")
    || normalized.includes("not initialized")
    || normalized.includes("method not found")
    || normalized.includes("request timeout")
    || normalized.includes("process exited before response");
}

function buildExecPrompt(prompt: string, context: PatchContext): string {
  const maxSummaryChars = Number(process.env.CODEX_EXEC_CONTEXT_SUMMARY_MAX_CHARS ?? "4000");
  const maxFileChars = Number(process.env.CODEX_EXEC_CONTEXT_FILE_MAX_CHARS ?? "3000");
  const maxFiles = Number(process.env.CODEX_EXEC_CONTEXT_MAX_FILES ?? "2");
  const maxPromptChars = Number(process.env.CODEX_EXEC_PROMPT_MAX_CHARS ?? "9000");

  const safeSummary = truncate(context.summary, maxSummaryChars);
  const files = context.files.slice(0, Math.max(0, maxFiles));
  const filesSection = context.files.length > 0
    ? files
      .map((file) => `FILE: ${file.path}\n${truncate(file.content, maxFileChars)}`)
      .join("\n\n")
    : "No file snippets available.";

  const raw = [
    "You are generating a git patch for CodexBridge.",
    "Return only a unified diff patch that can be applied with git apply.",
    "Do not include explanations or markdown fences.",
    `Task: ${prompt}`,
    "",
    "Workspace summary:",
    safeSummary,
    "",
    "File snippets:",
    filesSection,
    "",
    "Runtime context:",
    JSON.stringify(context.runtime ?? {}, null, 2)
  ].join("\n");

  return truncate(raw, maxPromptChars);
}

function parseCommandExecPatchResponse(response: unknown): { diff: string; summary: string } {
  if (!response || typeof response !== "object") {
    throw new Error("invalid command/exec response");
  }
  const value = response as Record<string, unknown>;
  const exitCode = Number(value.exitCode ?? 1);
  const stdout = typeof value.stdout === "string" ? value.stdout : "";
  const stderr = typeof value.stderr === "string" ? value.stderr : "";
  if (exitCode !== 0) {
    throw new Error(`codex exec failed: ${stderr || `exitCode=${exitCode}`}`);
  }

  const diff = extractDiff(stdout);
  if (!diff) {
    throw new Error("codex exec returned no diff content");
  }
  return {
    diff,
    summary: "patch generated by codex exec fallback"
  };
}

function extractDiff(output: string): string | undefined {
  const trimmed = output.trim();
  if (!trimmed) {
    return undefined;
  }

  const fenced = trimmed.match(/```diff\s*([\s\S]*?)```/i);
  if (fenced && fenced[1]) {
    return fenced[1].trim();
  }

  const diffMarker = trimmed.search(/^diff --git /m);
  if (diffMarker >= 0) {
    return trimmed.slice(diffMarker).trim();
  }

  if (/^--- .+\n\+\+\+ .+/m.test(trimmed) || /^@@ /m.test(trimmed)) {
    return trimmed;
  }

  return undefined;
}

function truncate(input: string, maxChars: number): string {
  const safeMax = Number.isFinite(maxChars) && maxChars > 0 ? Math.floor(maxChars) : 1000;
  if (input.length <= safeMax) {
    return input;
  }
  return `${input.slice(0, safeMax)}\n...[truncated]`;
}
